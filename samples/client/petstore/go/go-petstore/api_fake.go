/*
 * OpenAPI Petstore
 *
 * This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\
 *
 * API version: 1.0.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package petstore

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"os"
	"time"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

type FakeApi interface {

	/*
	 * CreateXmlItem creates an XmlItem
	 * this route creates an XmlItem
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiCreateXmlItemRequest
	 */
	CreateXmlItem(ctx _context.Context) ApiCreateXmlItemRequest

	/*
	 * CreateXmlItemExecute executes the request
	 */
	CreateXmlItemExecute(r ApiCreateXmlItemRequest) (*_nethttp.Response, error)

	/*
	 * FakeOuterBooleanSerialize Method for FakeOuterBooleanSerialize
	 * Test serialization of outer boolean types
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiFakeOuterBooleanSerializeRequest
	 */
	FakeOuterBooleanSerialize(ctx _context.Context) ApiFakeOuterBooleanSerializeRequest

	/*
	 * FakeOuterBooleanSerializeExecute executes the request
	 * @return bool
	 */
	FakeOuterBooleanSerializeExecute(r ApiFakeOuterBooleanSerializeRequest) (bool, *_nethttp.Response, error)

	/*
	 * FakeOuterCompositeSerialize Method for FakeOuterCompositeSerialize
	 * Test serialization of object with outer number type
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiFakeOuterCompositeSerializeRequest
	 */
	FakeOuterCompositeSerialize(ctx _context.Context) ApiFakeOuterCompositeSerializeRequest

	/*
	 * FakeOuterCompositeSerializeExecute executes the request
	 * @return OuterComposite
	 */
	FakeOuterCompositeSerializeExecute(r ApiFakeOuterCompositeSerializeRequest) (OuterComposite, *_nethttp.Response, error)

	/*
	 * FakeOuterNumberSerialize Method for FakeOuterNumberSerialize
	 * Test serialization of outer number types
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiFakeOuterNumberSerializeRequest
	 */
	FakeOuterNumberSerialize(ctx _context.Context) ApiFakeOuterNumberSerializeRequest

	/*
	 * FakeOuterNumberSerializeExecute executes the request
	 * @return float32
	 */
	FakeOuterNumberSerializeExecute(r ApiFakeOuterNumberSerializeRequest) (float32, *_nethttp.Response, error)

	/*
	 * FakeOuterStringSerialize Method for FakeOuterStringSerialize
	 * Test serialization of outer string types
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiFakeOuterStringSerializeRequest
	 */
	FakeOuterStringSerialize(ctx _context.Context) ApiFakeOuterStringSerializeRequest

	/*
	 * FakeOuterStringSerializeExecute executes the request
	 * @return string
	 */
	FakeOuterStringSerializeExecute(r ApiFakeOuterStringSerializeRequest) (string, *_nethttp.Response, error)

	/*
	 * TestBodyWithFileSchema Method for TestBodyWithFileSchema
	 * For this test, the body for this request much reference a schema named `File`.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiTestBodyWithFileSchemaRequest
	 */
	TestBodyWithFileSchema(ctx _context.Context) ApiTestBodyWithFileSchemaRequest

	/*
	 * TestBodyWithFileSchemaExecute executes the request
	 */
	TestBodyWithFileSchemaExecute(r ApiTestBodyWithFileSchemaRequest) (*_nethttp.Response, error)

	/*
	 * TestBodyWithQueryParams Method for TestBodyWithQueryParams
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiTestBodyWithQueryParamsRequest
	 */
	TestBodyWithQueryParams(ctx _context.Context) ApiTestBodyWithQueryParamsRequest

	/*
	 * TestBodyWithQueryParamsExecute executes the request
	 */
	TestBodyWithQueryParamsExecute(r ApiTestBodyWithQueryParamsRequest) (*_nethttp.Response, error)

	/*
	 * TestClientModel To test \"client\" model
	 * To test "client" model
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiTestClientModelRequest
	 */
	TestClientModel(ctx _context.Context) ApiTestClientModelRequest

	/*
	 * TestClientModelExecute executes the request
	 * @return Client
	 */
	TestClientModelExecute(r ApiTestClientModelRequest) (Client, *_nethttp.Response, error)

	/*
	 * TestEndpointParameters Fake endpoint for testing various parameters  假端點  偽のエンドポイント  가짜 엔드 포인트
	 * Fake endpoint for testing various parameters
 假端點
 偽のエンドポイント
 가짜 엔드 포인트
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiTestEndpointParametersRequest
	 */
	TestEndpointParameters(ctx _context.Context) ApiTestEndpointParametersRequest

	/*
	 * TestEndpointParametersExecute executes the request
	 */
	TestEndpointParametersExecute(r ApiTestEndpointParametersRequest) (*_nethttp.Response, error)

	/*
	 * TestEnumParameters To test enum parameters
	 * To test enum parameters
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiTestEnumParametersRequest
	 */
	TestEnumParameters(ctx _context.Context) ApiTestEnumParametersRequest

	/*
	 * TestEnumParametersExecute executes the request
	 */
	TestEnumParametersExecute(r ApiTestEnumParametersRequest) (*_nethttp.Response, error)

	/*
	 * TestGroupParameters Fake endpoint to test group parameters (optional)
	 * Fake endpoint to test group parameters (optional)
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiTestGroupParametersRequest
	 */
	TestGroupParameters(ctx _context.Context) ApiTestGroupParametersRequest

	/*
	 * TestGroupParametersExecute executes the request
	 */
	TestGroupParametersExecute(r ApiTestGroupParametersRequest) (*_nethttp.Response, error)

	/*
	 * TestInlineAdditionalProperties test inline additionalProperties
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiTestInlineAdditionalPropertiesRequest
	 */
	TestInlineAdditionalProperties(ctx _context.Context) ApiTestInlineAdditionalPropertiesRequest

	/*
	 * TestInlineAdditionalPropertiesExecute executes the request
	 */
	TestInlineAdditionalPropertiesExecute(r ApiTestInlineAdditionalPropertiesRequest) (*_nethttp.Response, error)

	/*
	 * TestJsonFormData test json serialization of form data
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiTestJsonFormDataRequest
	 */
	TestJsonFormData(ctx _context.Context) ApiTestJsonFormDataRequest

	/*
	 * TestJsonFormDataExecute executes the request
	 */
	TestJsonFormDataExecute(r ApiTestJsonFormDataRequest) (*_nethttp.Response, error)

	/*
	 * TestQueryParameterCollectionFormat Method for TestQueryParameterCollectionFormat
	 * To test the collection format in query parameters
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @return ApiTestQueryParameterCollectionFormatRequest
	 */
	TestQueryParameterCollectionFormat(ctx _context.Context) ApiTestQueryParameterCollectionFormatRequest

	/*
	 * TestQueryParameterCollectionFormatExecute executes the request
	 */
	TestQueryParameterCollectionFormatExecute(r ApiTestQueryParameterCollectionFormatRequest) (*_nethttp.Response, error)
}

// FakeApiService FakeApi service
type FakeApiService service

type ApiCreateXmlItemRequest struct {
	ctx _context.Context
	ApiService FakeApi
	bodyxmlItem *XmlItem
}

func (r ApiCreateXmlItemRequest) XmlItem(xmlItem XmlItem) ApiCreateXmlItemRequest {
	r.bodyxmlItem = &xmlItem
	return r
}

func (r ApiCreateXmlItemRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.CreateXmlItemExecute(r)
}

/*
 * CreateXmlItem creates an XmlItem
 * this route creates an XmlItem
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiCreateXmlItemRequest
 */
func (a *FakeApiService) CreateXmlItem(ctx _context.Context) ApiCreateXmlItemRequest {
	return ApiCreateXmlItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *FakeApiService) CreateXmlItemExecute(r ApiCreateXmlItemRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.CreateXmlItem")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake/create_xml_item"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.bodyxmlItem == nil {
		return nil, reportError("xmlItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/xml", "application/xml; charset=utf-8", "application/xml; charset=utf-16", "text/xml", "text/xml; charset=utf-8", "text/xml; charset=utf-16"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodyxmlItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFakeOuterBooleanSerializeRequest struct {
	ctx _context.Context
	ApiService FakeApi
	bodybody *bool
}

func (r ApiFakeOuterBooleanSerializeRequest) Body(body bool) ApiFakeOuterBooleanSerializeRequest {
	r.bodybody = &body
	return r
}

func (r ApiFakeOuterBooleanSerializeRequest) Execute() (bool, *_nethttp.Response, error) {
	return r.ApiService.FakeOuterBooleanSerializeExecute(r)
}

/*
 * FakeOuterBooleanSerialize Method for FakeOuterBooleanSerialize
 * Test serialization of outer boolean types
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiFakeOuterBooleanSerializeRequest
 */
func (a *FakeApiService) FakeOuterBooleanSerialize(ctx _context.Context) ApiFakeOuterBooleanSerializeRequest {
	return ApiFakeOuterBooleanSerializeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return bool
 */
func (a *FakeApiService) FakeOuterBooleanSerializeExecute(r ApiFakeOuterBooleanSerializeRequest) (bool, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.FakeOuterBooleanSerialize")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake/outer/boolean"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodybody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFakeOuterCompositeSerializeRequest struct {
	ctx _context.Context
	ApiService FakeApi
	bodybody *OuterComposite
}

func (r ApiFakeOuterCompositeSerializeRequest) Body(body OuterComposite) ApiFakeOuterCompositeSerializeRequest {
	r.bodybody = &body
	return r
}

func (r ApiFakeOuterCompositeSerializeRequest) Execute() (OuterComposite, *_nethttp.Response, error) {
	return r.ApiService.FakeOuterCompositeSerializeExecute(r)
}

/*
 * FakeOuterCompositeSerialize Method for FakeOuterCompositeSerialize
 * Test serialization of object with outer number type
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiFakeOuterCompositeSerializeRequest
 */
func (a *FakeApiService) FakeOuterCompositeSerialize(ctx _context.Context) ApiFakeOuterCompositeSerializeRequest {
	return ApiFakeOuterCompositeSerializeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return OuterComposite
 */
func (a *FakeApiService) FakeOuterCompositeSerializeExecute(r ApiFakeOuterCompositeSerializeRequest) (OuterComposite, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OuterComposite
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.FakeOuterCompositeSerialize")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake/outer/composite"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodybody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFakeOuterNumberSerializeRequest struct {
	ctx _context.Context
	ApiService FakeApi
	bodybody *float32
}

func (r ApiFakeOuterNumberSerializeRequest) Body(body float32) ApiFakeOuterNumberSerializeRequest {
	r.bodybody = &body
	return r
}

func (r ApiFakeOuterNumberSerializeRequest) Execute() (float32, *_nethttp.Response, error) {
	return r.ApiService.FakeOuterNumberSerializeExecute(r)
}

/*
 * FakeOuterNumberSerialize Method for FakeOuterNumberSerialize
 * Test serialization of outer number types
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiFakeOuterNumberSerializeRequest
 */
func (a *FakeApiService) FakeOuterNumberSerialize(ctx _context.Context) ApiFakeOuterNumberSerializeRequest {
	return ApiFakeOuterNumberSerializeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return float32
 */
func (a *FakeApiService) FakeOuterNumberSerializeExecute(r ApiFakeOuterNumberSerializeRequest) (float32, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  float32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.FakeOuterNumberSerialize")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake/outer/number"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodybody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFakeOuterStringSerializeRequest struct {
	ctx _context.Context
	ApiService FakeApi
	bodybody *string
}

func (r ApiFakeOuterStringSerializeRequest) Body(body string) ApiFakeOuterStringSerializeRequest {
	r.bodybody = &body
	return r
}

func (r ApiFakeOuterStringSerializeRequest) Execute() (string, *_nethttp.Response, error) {
	return r.ApiService.FakeOuterStringSerializeExecute(r)
}

/*
 * FakeOuterStringSerialize Method for FakeOuterStringSerialize
 * Test serialization of outer string types
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiFakeOuterStringSerializeRequest
 */
func (a *FakeApiService) FakeOuterStringSerialize(ctx _context.Context) ApiFakeOuterStringSerializeRequest {
	return ApiFakeOuterStringSerializeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return string
 */
func (a *FakeApiService) FakeOuterStringSerializeExecute(r ApiFakeOuterStringSerializeRequest) (string, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.FakeOuterStringSerialize")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake/outer/string"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodybody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestBodyWithFileSchemaRequest struct {
	ctx _context.Context
	ApiService FakeApi
	bodybody *FileSchemaTestClass
}

func (r ApiTestBodyWithFileSchemaRequest) Body(body FileSchemaTestClass) ApiTestBodyWithFileSchemaRequest {
	r.bodybody = &body
	return r
}

func (r ApiTestBodyWithFileSchemaRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TestBodyWithFileSchemaExecute(r)
}

/*
 * TestBodyWithFileSchema Method for TestBodyWithFileSchema
 * For this test, the body for this request much reference a schema named `File`.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiTestBodyWithFileSchemaRequest
 */
func (a *FakeApiService) TestBodyWithFileSchema(ctx _context.Context) ApiTestBodyWithFileSchemaRequest {
	return ApiTestBodyWithFileSchemaRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *FakeApiService) TestBodyWithFileSchemaExecute(r ApiTestBodyWithFileSchemaRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.TestBodyWithFileSchema")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake/body-with-file-schema"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.bodybody == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodybody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestBodyWithQueryParamsRequest struct {
	ctx _context.Context
	ApiService FakeApi
	queryquery *string
	bodybody *User
}

func (r ApiTestBodyWithQueryParamsRequest) QueryQuery(query string) ApiTestBodyWithQueryParamsRequest {
	r.queryquery = &query
	return r
}
func (r ApiTestBodyWithQueryParamsRequest) Body(body User) ApiTestBodyWithQueryParamsRequest {
	r.bodybody = &body
	return r
}

func (r ApiTestBodyWithQueryParamsRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TestBodyWithQueryParamsExecute(r)
}

/*
 * TestBodyWithQueryParams Method for TestBodyWithQueryParams
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiTestBodyWithQueryParamsRequest
 */
func (a *FakeApiService) TestBodyWithQueryParams(ctx _context.Context) ApiTestBodyWithQueryParamsRequest {
	return ApiTestBodyWithQueryParamsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *FakeApiService) TestBodyWithQueryParamsExecute(r ApiTestBodyWithQueryParamsRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.TestBodyWithQueryParams")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake/body-with-query-params"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.queryquery == nil {
		return nil, reportError("query is required and must be specified")
	}
	if r.bodybody == nil {
		return nil, reportError("body is required and must be specified")
	}

	localVarQueryParams.Add("query", parameterToString(*r.queryquery, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodybody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestClientModelRequest struct {
	ctx _context.Context
	ApiService FakeApi
	bodybody *Client
}

func (r ApiTestClientModelRequest) Body(body Client) ApiTestClientModelRequest {
	r.bodybody = &body
	return r
}

func (r ApiTestClientModelRequest) Execute() (Client, *_nethttp.Response, error) {
	return r.ApiService.TestClientModelExecute(r)
}

/*
 * TestClientModel To test \"client\" model
 * To test "client" model
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiTestClientModelRequest
 */
func (a *FakeApiService) TestClientModel(ctx _context.Context) ApiTestClientModelRequest {
	return ApiTestClientModelRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Client
 */
func (a *FakeApiService) TestClientModelExecute(r ApiTestClientModelRequest) (Client, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPatch
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Client
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.TestClientModel")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.bodybody == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodybody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestEndpointParametersRequest struct {
	ctx _context.Context
	ApiService FakeApi
	formnumber *float32
	formdouble *float64
	formpatternWithoutDelimiter *string
	formbyte_ *string
	forminteger *int32
	formint32_ *int32
	formint64_ *int64
	formfloat *float32
	formstring_ *string
	formbinary **os.File
	formdate *string
	formdateTime *time.Time
	formpassword *string
	formcallback *string
}

func (r ApiTestEndpointParametersRequest) Number(number float32) ApiTestEndpointParametersRequest {
	r.formnumber = &number
	return r
}
func (r ApiTestEndpointParametersRequest) Double(double float64) ApiTestEndpointParametersRequest {
	r.formdouble = &double
	return r
}
func (r ApiTestEndpointParametersRequest) PatternWithoutDelimiter(patternWithoutDelimiter string) ApiTestEndpointParametersRequest {
	r.formpatternWithoutDelimiter = &patternWithoutDelimiter
	return r
}
func (r ApiTestEndpointParametersRequest) Byte_(byte_ string) ApiTestEndpointParametersRequest {
	r.formbyte_ = &byte_
	return r
}
func (r ApiTestEndpointParametersRequest) Integer(integer int32) ApiTestEndpointParametersRequest {
	r.forminteger = &integer
	return r
}
func (r ApiTestEndpointParametersRequest) Int32_(int32_ int32) ApiTestEndpointParametersRequest {
	r.formint32_ = &int32_
	return r
}
func (r ApiTestEndpointParametersRequest) Int64_(int64_ int64) ApiTestEndpointParametersRequest {
	r.formint64_ = &int64_
	return r
}
func (r ApiTestEndpointParametersRequest) Float(float float32) ApiTestEndpointParametersRequest {
	r.formfloat = &float
	return r
}
func (r ApiTestEndpointParametersRequest) String_(string_ string) ApiTestEndpointParametersRequest {
	r.formstring_ = &string_
	return r
}
func (r ApiTestEndpointParametersRequest) Binary(binary *os.File) ApiTestEndpointParametersRequest {
	r.formbinary = &binary
	return r
}
func (r ApiTestEndpointParametersRequest) Date(date string) ApiTestEndpointParametersRequest {
	r.formdate = &date
	return r
}
func (r ApiTestEndpointParametersRequest) DateTime(dateTime time.Time) ApiTestEndpointParametersRequest {
	r.formdateTime = &dateTime
	return r
}
func (r ApiTestEndpointParametersRequest) Password(password string) ApiTestEndpointParametersRequest {
	r.formpassword = &password
	return r
}
func (r ApiTestEndpointParametersRequest) Callback(callback string) ApiTestEndpointParametersRequest {
	r.formcallback = &callback
	return r
}

func (r ApiTestEndpointParametersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TestEndpointParametersExecute(r)
}

/*
 * TestEndpointParameters Fake endpoint for testing various parameters  假端點  偽のエンドポイント  가짜 엔드 포인트
 * Fake endpoint for testing various parameters
 假端點
 偽のエンドポイント
 가짜 엔드 포인트
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiTestEndpointParametersRequest
 */
func (a *FakeApiService) TestEndpointParameters(ctx _context.Context) ApiTestEndpointParametersRequest {
	return ApiTestEndpointParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *FakeApiService) TestEndpointParametersExecute(r ApiTestEndpointParametersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.TestEndpointParameters")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.formnumber == nil {
		return nil, reportError("number is required and must be specified")
	}
	if *r.formnumber < 32.1 {
		return nil, reportError("number must be greater than 32.1")
	}
	if *r.formnumber > 543.2 {
		return nil, reportError("number must be less than 543.2")
	}
	if r.formdouble == nil {
		return nil, reportError("double is required and must be specified")
	}
	if *r.formdouble < 67.8 {
		return nil, reportError("double must be greater than 67.8")
	}
	if *r.formdouble > 123.4 {
		return nil, reportError("double must be less than 123.4")
	}
	if r.formpatternWithoutDelimiter == nil {
		return nil, reportError("patternWithoutDelimiter is required and must be specified")
	}
	if r.formbyte_ == nil {
		return nil, reportError("byte_ is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.forminteger != nil {
		localVarFormParams.Add("integer", parameterToString(*r.forminteger, ""))
	}
	if r.formint32_ != nil {
		localVarFormParams.Add("int32", parameterToString(*r.formint32_, ""))
	}
	if r.formint64_ != nil {
		localVarFormParams.Add("int64", parameterToString(*r.formint64_, ""))
	}
	localVarFormParams.Add("number", parameterToString(*r.formnumber, ""))
	if r.formfloat != nil {
		localVarFormParams.Add("float", parameterToString(*r.formfloat, ""))
	}
	localVarFormParams.Add("double", parameterToString(*r.formdouble, ""))
	if r.formstring_ != nil {
		localVarFormParams.Add("string", parameterToString(*r.formstring_, ""))
	}
	localVarFormParams.Add("pattern_without_delimiter", parameterToString(*r.formpatternWithoutDelimiter, ""))
	localVarFormParams.Add("byte", parameterToString(*r.formbyte_, ""))
	localVarFormFileName = "binary"
	var localVarFile *os.File
	if r.formbinary != nil {
		localVarFile = *r.formbinary
	}
	if localVarFile != nil {
		fbs, _ := _ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if r.formdate != nil {
		localVarFormParams.Add("date", parameterToString(*r.formdate, ""))
	}
	if r.formdateTime != nil {
		localVarFormParams.Add("dateTime", parameterToString(*r.formdateTime, ""))
	}
	if r.formpassword != nil {
		localVarFormParams.Add("password", parameterToString(*r.formpassword, ""))
	}
	if r.formcallback != nil {
		localVarFormParams.Add("callback", parameterToString(*r.formcallback, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestEnumParametersRequest struct {
	ctx _context.Context
	ApiService FakeApi
	headerenumHeaderStringArray *[]string
	headerenumHeaderString *string
	queryenumQueryStringArray *[]string
	queryenumQueryString *string
	queryenumQueryInteger *int32
	queryenumQueryDouble *float64
	formenumFormStringArray *[]string
	formenumFormString *string
}

func (r ApiTestEnumParametersRequest) HeaderEnumHeaderStringArray(enumHeaderStringArray []string) ApiTestEnumParametersRequest {
	r.headerenumHeaderStringArray = &enumHeaderStringArray
	return r
}
func (r ApiTestEnumParametersRequest) HeaderEnumHeaderString(enumHeaderString string) ApiTestEnumParametersRequest {
	r.headerenumHeaderString = &enumHeaderString
	return r
}
func (r ApiTestEnumParametersRequest) QueryEnumQueryStringArray(enumQueryStringArray []string) ApiTestEnumParametersRequest {
	r.queryenumQueryStringArray = &enumQueryStringArray
	return r
}
func (r ApiTestEnumParametersRequest) QueryEnumQueryString(enumQueryString string) ApiTestEnumParametersRequest {
	r.queryenumQueryString = &enumQueryString
	return r
}
func (r ApiTestEnumParametersRequest) QueryEnumQueryInteger(enumQueryInteger int32) ApiTestEnumParametersRequest {
	r.queryenumQueryInteger = &enumQueryInteger
	return r
}
func (r ApiTestEnumParametersRequest) QueryEnumQueryDouble(enumQueryDouble float64) ApiTestEnumParametersRequest {
	r.queryenumQueryDouble = &enumQueryDouble
	return r
}
func (r ApiTestEnumParametersRequest) EnumFormStringArray(enumFormStringArray []string) ApiTestEnumParametersRequest {
	r.formenumFormStringArray = &enumFormStringArray
	return r
}
func (r ApiTestEnumParametersRequest) EnumFormString(enumFormString string) ApiTestEnumParametersRequest {
	r.formenumFormString = &enumFormString
	return r
}

func (r ApiTestEnumParametersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TestEnumParametersExecute(r)
}

/*
 * TestEnumParameters To test enum parameters
 * To test enum parameters
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiTestEnumParametersRequest
 */
func (a *FakeApiService) TestEnumParameters(ctx _context.Context) ApiTestEnumParametersRequest {
	return ApiTestEnumParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *FakeApiService) TestEnumParametersExecute(r ApiTestEnumParametersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.TestEnumParameters")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.queryenumQueryStringArray != nil {
		localVarQueryParams.Add("enum_query_string_array", parameterToString(*r.queryenumQueryStringArray, "csv"))
	}
	if r.queryenumQueryString != nil {
		localVarQueryParams.Add("enum_query_string", parameterToString(*r.queryenumQueryString, ""))
	}
	if r.queryenumQueryInteger != nil {
		localVarQueryParams.Add("enum_query_integer", parameterToString(*r.queryenumQueryInteger, ""))
	}
	if r.queryenumQueryDouble != nil {
		localVarQueryParams.Add("enum_query_double", parameterToString(*r.queryenumQueryDouble, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.headerenumHeaderStringArray != nil {
		localVarHeaderParams["enum_header_string_array"] = parameterToString(*r.headerenumHeaderStringArray, "csv")
	}
	if r.headerenumHeaderString != nil {
		localVarHeaderParams["enum_header_string"] = parameterToString(*r.headerenumHeaderString, "")
	}
	if r.formenumFormStringArray != nil {
		localVarFormParams.Add("enum_form_string_array", parameterToString(*r.formenumFormStringArray, "csv"))
	}
	if r.formenumFormString != nil {
		localVarFormParams.Add("enum_form_string", parameterToString(*r.formenumFormString, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestGroupParametersRequest struct {
	ctx _context.Context
	ApiService FakeApi
	queryrequiredStringGroup *int32
	headerrequiredBooleanGroup *bool
	queryrequiredInt64Group *int64
	querystringGroup *int32
	headerbooleanGroup *bool
	queryint64Group *int64
}

func (r ApiTestGroupParametersRequest) RequiredStringGroup(requiredStringGroup int32) ApiTestGroupParametersRequest {
	r.queryrequiredStringGroup = &requiredStringGroup
	return r
}
func (r ApiTestGroupParametersRequest) HeaderRequiredBooleanGroup(requiredBooleanGroup bool) ApiTestGroupParametersRequest {
	r.headerrequiredBooleanGroup = &requiredBooleanGroup
	return r
}
func (r ApiTestGroupParametersRequest) RequiredInt64Group(requiredInt64Group int64) ApiTestGroupParametersRequest {
	r.queryrequiredInt64Group = &requiredInt64Group
	return r
}
func (r ApiTestGroupParametersRequest) StringGroup(stringGroup int32) ApiTestGroupParametersRequest {
	r.querystringGroup = &stringGroup
	return r
}
func (r ApiTestGroupParametersRequest) HeaderBooleanGroup(booleanGroup bool) ApiTestGroupParametersRequest {
	r.headerbooleanGroup = &booleanGroup
	return r
}
func (r ApiTestGroupParametersRequest) Int64Group(int64Group int64) ApiTestGroupParametersRequest {
	r.queryint64Group = &int64Group
	return r
}

func (r ApiTestGroupParametersRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TestGroupParametersExecute(r)
}

/*
 * TestGroupParameters Fake endpoint to test group parameters (optional)
 * Fake endpoint to test group parameters (optional)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiTestGroupParametersRequest
 */
func (a *FakeApiService) TestGroupParameters(ctx _context.Context) ApiTestGroupParametersRequest {
	return ApiTestGroupParametersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *FakeApiService) TestGroupParametersExecute(r ApiTestGroupParametersRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.TestGroupParameters")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.queryrequiredStringGroup == nil {
		return nil, reportError("requiredStringGroup is required and must be specified")
	}
	if r.headerrequiredBooleanGroup == nil {
		return nil, reportError("requiredBooleanGroup is required and must be specified")
	}
	if r.queryrequiredInt64Group == nil {
		return nil, reportError("requiredInt64Group is required and must be specified")
	}

	localVarQueryParams.Add("required_string_group", parameterToString(*r.queryrequiredStringGroup, ""))
	localVarQueryParams.Add("required_int64_group", parameterToString(*r.queryrequiredInt64Group, ""))
	if r.querystringGroup != nil {
		localVarQueryParams.Add("string_group", parameterToString(*r.querystringGroup, ""))
	}
	if r.queryint64Group != nil {
		localVarQueryParams.Add("int64_group", parameterToString(*r.queryint64Group, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["required_boolean_group"] = parameterToString(*r.headerrequiredBooleanGroup, "")
	if r.headerbooleanGroup != nil {
		localVarHeaderParams["boolean_group"] = parameterToString(*r.headerbooleanGroup, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestInlineAdditionalPropertiesRequest struct {
	ctx _context.Context
	ApiService FakeApi
	bodyparam *map[string]string
}

func (r ApiTestInlineAdditionalPropertiesRequest) Param(param map[string]string) ApiTestInlineAdditionalPropertiesRequest {
	r.bodyparam = &param
	return r
}

func (r ApiTestInlineAdditionalPropertiesRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TestInlineAdditionalPropertiesExecute(r)
}

/*
 * TestInlineAdditionalProperties test inline additionalProperties
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiTestInlineAdditionalPropertiesRequest
 */
func (a *FakeApiService) TestInlineAdditionalProperties(ctx _context.Context) ApiTestInlineAdditionalPropertiesRequest {
	return ApiTestInlineAdditionalPropertiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *FakeApiService) TestInlineAdditionalPropertiesExecute(r ApiTestInlineAdditionalPropertiesRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.TestInlineAdditionalProperties")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake/inline-additionalProperties"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.bodyparam == nil {
		return nil, reportError("param is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodyparam
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestJsonFormDataRequest struct {
	ctx _context.Context
	ApiService FakeApi
	formparam *string
	formparam2 *string
}

func (r ApiTestJsonFormDataRequest) Param(param string) ApiTestJsonFormDataRequest {
	r.formparam = &param
	return r
}
func (r ApiTestJsonFormDataRequest) Param2(param2 string) ApiTestJsonFormDataRequest {
	r.formparam2 = &param2
	return r
}

func (r ApiTestJsonFormDataRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TestJsonFormDataExecute(r)
}

/*
 * TestJsonFormData test json serialization of form data
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiTestJsonFormDataRequest
 */
func (a *FakeApiService) TestJsonFormData(ctx _context.Context) ApiTestJsonFormDataRequest {
	return ApiTestJsonFormDataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *FakeApiService) TestJsonFormDataExecute(r ApiTestJsonFormDataRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.TestJsonFormData")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake/jsonFormData"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.formparam == nil {
		return nil, reportError("param is required and must be specified")
	}
	if r.formparam2 == nil {
		return nil, reportError("param2 is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarFormParams.Add("param", parameterToString(*r.formparam, ""))
	localVarFormParams.Add("param2", parameterToString(*r.formparam2, ""))
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestQueryParameterCollectionFormatRequest struct {
	ctx _context.Context
	ApiService FakeApi
	querypipe *[]string
	queryioutil *[]string
	queryhttp *[]string
	queryurl *[]string
	querycontext *[]string
}

func (r ApiTestQueryParameterCollectionFormatRequest) Pipe(pipe []string) ApiTestQueryParameterCollectionFormatRequest {
	r.querypipe = &pipe
	return r
}
func (r ApiTestQueryParameterCollectionFormatRequest) Ioutil(ioutil []string) ApiTestQueryParameterCollectionFormatRequest {
	r.queryioutil = &ioutil
	return r
}
func (r ApiTestQueryParameterCollectionFormatRequest) Http(http []string) ApiTestQueryParameterCollectionFormatRequest {
	r.queryhttp = &http
	return r
}
func (r ApiTestQueryParameterCollectionFormatRequest) Url(url []string) ApiTestQueryParameterCollectionFormatRequest {
	r.queryurl = &url
	return r
}
func (r ApiTestQueryParameterCollectionFormatRequest) Context(context []string) ApiTestQueryParameterCollectionFormatRequest {
	r.querycontext = &context
	return r
}

func (r ApiTestQueryParameterCollectionFormatRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.TestQueryParameterCollectionFormatExecute(r)
}

/*
 * TestQueryParameterCollectionFormat Method for TestQueryParameterCollectionFormat
 * To test the collection format in query parameters
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiTestQueryParameterCollectionFormatRequest
 */
func (a *FakeApiService) TestQueryParameterCollectionFormat(ctx _context.Context) ApiTestQueryParameterCollectionFormatRequest {
	return ApiTestQueryParameterCollectionFormatRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *FakeApiService) TestQueryParameterCollectionFormatExecute(r ApiTestQueryParameterCollectionFormatRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FakeApiService.TestQueryParameterCollectionFormat")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fake/test-query-paramters"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.querypipe == nil {
		return nil, reportError("pipe is required and must be specified")
	}
	if r.queryioutil == nil {
		return nil, reportError("ioutil is required and must be specified")
	}
	if r.queryhttp == nil {
		return nil, reportError("http is required and must be specified")
	}
	if r.queryurl == nil {
		return nil, reportError("url is required and must be specified")
	}
	if r.querycontext == nil {
		return nil, reportError("context is required and must be specified")
	}

	localVarQueryParams.Add("pipe", parameterToString(*r.querypipe, "csv"))
	localVarQueryParams.Add("ioutil", parameterToString(*r.queryioutil, "csv"))
	localVarQueryParams.Add("http", parameterToString(*r.queryhttp, "ssv"))
	localVarQueryParams.Add("url", parameterToString(*r.queryurl, "csv"))
	{
		t := *r.querycontext
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("context", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("context", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
